# 연관관계 매핑 기초
```text
객체의 참조와 외래 키를 매핑

기존의 SQL 식으로 연관 관계를 매핑 시(db에 Long 형식으로 fk 를 모델링하면
-> 객체를 테이블에 맞추어 데이터 중심으로 모델링하면 협력 관계를 만들 수 없음
```
## 단방향 연관관계
* COMMIT 으로 확인 !! 코드로 올렸음. 

## 양방향 연관관계와 연관관계의 주인
### 객체 VS TABLE
* 객체: 참조
  * 양방향으로 설정해두지 않으면 양방향 연관관계가 아님.
  * 단방향임. 
  * 리스트를 넣어줘야지 양방향이 될 수 있는 것임.
* Table: pk, fk로 찾음. 
  * 테이블의 경우에는 fk로 연결되어 있기 때문에 모두 다 양방향으로 연결되어 있음.

### 양방향 연관관게
  * 양쪽으로 참조가 되어 있는 것
  * 테이블은 전혀 변화가 없음 
  * `mappedBy`
    * `@OneToMany(mappedBy = "team")`
    * 다른 쪽의 manyToOne에 연결된 attribute의 이름을 적어둠.
  * 객체는 단뱡향으로 된 것이 좋긴 함

### 객체와 테이블이 관계를 맺는 차이
* 객체 연관관계 = 2개 (각각 단방향)
  * 회원 `->` 팀, 팀 `->` 회원
* 테이블 연관관계 = 1개 (양방향)
  * 회원 `<-->` 팀
  * fk 값 하나로 모든 연관관계가 끝이 남.

### 객체의 양방향 관계
* 양방향이 아니라 서로 다른 단방향 2개임


### 연관관계의 주인
* 그렇기 때문에 fk를 정해야 함.
    * member에 저장된 team이 fk가 될지, team에 있는 list로된 member가 fk가 될지
* 연관관계의 주인만이 외래키를 관리
* `주인이 아닌 쪽은 읽기만 가능`
* 실제 값을 변경할 수 없음.
* 주인은 mappedBy를 사용할 수 없음, 주인이 아닌 객체가 mappedBy로 주인을 지정

### 누구를 주인으로?
* 연관관계 주인: 진짜 매핑
  * 외래키가 있는 곳을 주인으로
* 주인의 반대편: 가짜 매핑



